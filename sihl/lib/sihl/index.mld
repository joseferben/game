{0 Sihl}

{%html:
<p align="center">
  <a href="https://github.com/oxidizing/sihl">
    <img style="display: block; margin: 0 auto;" src="https://github.com/oxidizing/sihl/blob/master/images/logo.png?raw=true" alt="Logo"/>
  </a>
</p>
%}

Sihl is a batteries-included web framework.

{1 Sihl at a glance}

You can also jump into the {!documentation}, get started with the {!tutorial} or read the {!api} API.

{2 Design your model}

[lib/models/user.ml]
{[
module User = struct
  type t =
    { id : string
    ; email : string [@model.email]
    ; short_name : string
    ; customer_id : int [@model.fk "customers", cascade]
    ; full_name : string
    ; created_at : Ptime.t [@model.default now]
    ; updated_at : Ptime.t
    }
  [@@deriving show, model { namespace = "user" }]
end
]}

[lib/models/customer.ml]
{[
module Customer = struct
  type tier =
    | Premium
    | Top
    | Business
  [@@deriving show]

  type t =
    { id : string
    ; user_id : string [@model.fk User.t]
    ; shipments : int
    ; tier : tier
    ; created_at : Ptime.t
    ; updated_at : Ptime.t
    }
  [@@deriving show, model]
]}

{2 Migrate the database}

{v $ sihl migrate.generate v}
{v $ sihl migrate.up v}

{2 Design your URLs}

[lib/app.ml]
{[
let routes =
  [ Dream.get "/" Handlers.home
  ; Dream.scope "/users" [] Sihl.User.routes
  ; Dream.scope
      "/orders"
      [ Sihl.User.authentication_required ]
      [ Dream.get "/" Handlers.order_list
      ; Dream.get "/:id" Handlers.order_detail
      ; Dream.get "/create" Handlers.order_create
      ]
  ]
;;
]}

{2 Build your handlers}
todo

{2 Design your templates}
[lib/templates/customer_list.re]
{[
open Tyxml;

let createElement = (~title, ~children=[], ()) => {
  <html>
    <head>
      <title> {Html.txt(title)} </title>
      <link rel="stylesheet" href="home.css" />
    </head>
    <body> ...children </body>
  </html>;
};
]}

{1:getting_started Getting Started}

If you want to jump into code, have a look at {{:https://github.com/oxidizing/sihl-demo} the demo project}. Otherwise keep reading and get started by creating your own app from scratch.

{2 Prerequisites}

All you need is {{:https://opam.ocaml.org/doc/Install.html} opam}. {{:https://ocaml.org/learn/tutorials/up_and_running.html} This guide} walks you through setting up a development environment.

It is also recommended that you know OCaml's standard library and {{:https://github.com/ocsigen/lwt} Lwt}. This documentation explains a lot of concepts in terms of types, so you should be comfortable reading type signatures. If you are a beginner, check out the section {{!learn_ocaml} OCaml for web development in Sihl}..

{2 First Steps}

Install Sihl with

{v opam install sihl v}

and generate an app [my_app].

{v sihl init my_app v}

{2 Directory Structure}

The default directory structure provides a good starting point to scale up the app. You should not remove directories, but feel free to organize your code within the existing structure.

{v
â”œâ”€â”€ bin
â”œâ”€â”€ lib
â”‚   â”œâ”€â”€ app.ml
â”‚   â”œâ”€â”€ forms
â”‚   â”œâ”€â”€ handlers
â”‚   â”œâ”€â”€ models
â”‚   â””â”€â”€ templates
â”œâ”€â”€ settings
â”œâ”€â”€ migrations
â””â”€â”€ test
v}

{3 The Bin Directory}
The [bin] directory contains is the entry point to your application. This is where the executable comes from.

{3 The Lib Directory}
The [lib] directory contains the actual web app. Sihl suggests a structure but in [lib] you are allowed to do whatever you want without breaking Sihl apps.

The [app.ml] file is where everyting comes together. Consequently, [app.ml] is allowed to know everyone else in the [lib] directory.

The [commands] directory contains custom CLI commands to extend the Sihl CLI.

The [forms] directory contains form descriptions to parse and validate incoming user data.

The [handlers] directory contains HTTP handlers. A handler return a response given a request and is connected to a route.

The [middlewares] directory contains HTTP middlewares.

The [models] directory contains types and combinators for those types.

The [templates] directory contains HTML templates or JSON serializers.

{3 The Settings Directory}
The [settings] directory contains the app configuration.

{3 The Migrations Directory}
The [migrations] directory contains datatbase migration pairs. A migration pair comprises of an up and a down migration file, written in SQL.

{2 Running the web app}

The CLI tool [sihl] provides a set of useful commands.

{v $ sihl
Sihl 4.0.0
Type "sihl COMMAND --help" for more details, sihl help to see all commands"

Commands:
  build          Build a web app executable and bundle the static assets.
  db.create      Set up the database at DATABASE_URL.
  db.destroy     Delete the database at DATABASE_URL.
  dev            Start the local web server in auto-reload mode.
  email          Send an email.
  gen.migration  Generate CREATE TABLE migrations for all registered models.
  migrate        Run all pending database migrations.
  migrate.down   Revert the last database migration.
  models         Print all models.
  routes         Print all HTTP routes.
  test           Run all tests.
  test.coverage  Run tests and show coverage report.
  user.super     Create a user with superuser permissions.
  user.staff     Create a user with staff permissions.
v}

Let's see what we can do with [dev]

{v $ sihl dev --help
Usage: sihl dev [-p|--port]
Start the web server and the asset compilation process in watch mode.

Examples:
  sihl dev -p 3001
v}

Start the web app with

{v $ sihl dev v}

{1:documentation Documentation}

{2 Settings}

{!module:Sihl.Settings}
One of the design goals of Sihl is safety. A Sihl app does not start if the required configurations are not present. In many cases, it does not even compile.

Settings live in the root [settings] directory.

{v
â””â”€â”€ settings
    â”œâ”€â”€ base.ml
    â”œâ”€â”€ production.ml
    â”œâ”€â”€ local.ml
    â””â”€â”€ test.ml
v}

Settings that are shared among all environments go to [base.ml].

The three other files [production.ml], [local.ml] and [test.ml] contain settings for the respecitive environment. They all include the base settings which they can override.

[settings/base.ml]
{[
  let database_url = "postgresql://admin:password@127.0.0.1:5432/dev"
  let debug = Sihl.Env.bool "SIHL_DEBUG"
  let test = Sihl.Env.bool "SIHL_TEST"
  let sihl_secret = "local_SBw74Pe8hYPReC57e9Ag8xd36y6R9yxhFX6MqE66XPxoAiTsyfayF3q5EfbWXbbV"
  let email_default_subject = "Hello there ðŸ‘‹"
]}

[settings/local.ml]
{[
  let debug = Sihl.Env.bool ~default:true "SIHL_DEBUG"
  let test = Sihl.Env.bool ~default:false "SIHL_TEST"
]}

[settings/production.ml]
{[
  let database_url = Sihl.Env.string "DATABASE_URL"
  let debug = false
  let test = false
  let sihl_secret = Sihl.Env.string "SIHL_SECRET"
]}

Use {!module:Sihl.Env} to access values from environment variables. Sihl automatically loads values found in a [.env] file in the root of the project.

{3 Reading Configuration}

In order to read configuration use

{[module Config = (val !Settings.config : Settings.S)]}

just like

{[
module Config = (val !Settings.config : Settings.S)

let recipients = [...] in
let%lwt () = Sihl.Mail.send ~subject:Config.email_default_subject "This is the body" recipients
]}

{2 Web}

Sihl is built on top of {{:https://github.com/aantron/dream} Dream} which takes care of almost everything HTTP related. The {{:https://aantron.github.io/dream/} documentation} is a great starting point and very well done.

The routes are the HTTP entry points to your app. They describe what can be done in a declarative way.

{2 Model}

{2 Database Migration}

{2 Database Querie}

{2 Seeding}

{2 Testing}

OCaml catches many bugs at compile-time and Sihl enforces certain invariants at start-up time. Howver, there are still many bugs out there that need to be caught. Automated tests can be a great tool to complement the safety of OCaml and Sihl.

Have a look at {{:https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/data/tdd.html} this introduction to test-driven development} in OCaml.

Sihl uses {{:https://github.com/mirage/alcotest} Alcotest} as a test runner.

{3 Arrange-Act-Assert}

Structure your tests using {{:https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019} Arrange-Act-Assert}.

Arranging your state requires you to clean up first. You don't have direct access to remove the state of infrastructure services provided by Sihl or Sihl packages such as [sihl-user]. In order to clean their state you can use {!Sihl.Cleaner.clean_all}.

{[
let create_list_and_do _ () =
  let open Todo.Model in
  let%lwt () = Sihl.Cleaner.clean_all () in
  let%lwt _ = Todo.create "do laundry" in
  let%lwt _ = Todo.create "hoover" in
  let%lwt todos = Todo.search 10 in
  let t1, t2 =
    match todos with
    | [ t1; t2 ], n ->
      Alcotest.(check int "has 2" 2 n);
      t1, t2
    | _ -> Alcotest.fail "Unexpected number of todos received"
  in
  Alcotest.(check string "has description" "hoover" t1.description);
  Alcotest.(check string "has description" "do laundry" t2.description);
  let%lwt () = Todo.do_ t1 in
  let%lwt t1 = Todo.find t1.id in
  Alcotest.(check bool "is done" true (Todo.is_done t1));
  Lwt.return ()
;;
]}

If you have complex pre-conditions, you should move the service calls to the [database] directory and create seeds out of them. Parametrize the seeds as needed for re-use in other tests.

{2 Pagination & Search}

Displaying things and collections of things is a common thing in web development. Often we don't want to display all the items that are stored, but present the user a nice interface to search collections.

Sihl services usually follow a convention where they expose a function

{[
val search:
  ?sort:[ `Asc | `Desc ] ->
  ?filter:string ->
  ?limit:int ->
  ?offset:int ->
  unit ->
  (t list * int) Lwt.t
]}

that can be used to fetch, sort and filter a partial view on the whole collection of [t].

To implement your own function with this signature, use {!Sihl.Database.prepare_search_request} and {!Sihl.Database.run_search_request}:

{[
  let filter_fragment =
    {sql|
        WHERE user_users.email LIKE $1
          OR user_users.username LIKE $1
          OR user_users.status LIKE $1 |sql}
  ;;

  (* We need to escape this SQL query because
     it breaks syntax highlghting of the documentation *)
  let search_query =
    {sql|
        SELECT
          COUNT(\*\) OVER() as total,
          uuid,
          email,
          username,
          password,
          status,
          admin,
          confirmed,
          created_at,
          updated_at
        FROM user_users |sql}
  ;;

  let request =
    Sihl.Database.prepare_search_request
      ~search_query
      ~filter_fragment
      ~sort_by_field:"id"
      user
  ;;

  let search sort filter ~limit ~offset =
      Sihl.Database.run_search_request
        connection
        request
        sort
        filter
        ~limit
        ~offset
  ;;
]}

The first column of the [search_query] needs to be the total number of rows after applying the filter. The total number is higher than the limit, if there are a lot of rows.

Note that if you need features like sorting on multiple columns or complex filters, you have to take care of safely building your SQL queries at runtime. The approach shown above is safe from SQL injection, fast (due to prepared statements) and simple to use.

Using offset-based pagination comes with {{:https://uxdesign.cc/why-facebook-says-cursor-pagination-is-the-greatest-d6b98d86b6c0}some drawbacks} that you should be aware of.

{2 Compiling assets}

The project template has a asset pipeline set up that watches files in the [resource] directory and compiles assets into the [public] directory. Run [make assets] to compile the assets once and [make assets_watch] for watch for file changes.

{{:https://parceljs.org/} ParcelJS} is used to have a zero configuration experience when dealing with all sorts of assets types.

By default, Sihl serves static files from the [public] directory.

{2 File Storage}

{3 Retrieving files}

Sihl serves the [public] directory under the path [/assets] by default using {!val:Sihl.Web.Middleware.static_file}.

You can configure the directory to be served using [PUBLIC_DIR]. The URI prefix can be configured using [PUBLIC_URI_PREFIX].

{3 Uploading files}

This feature is not implemented in Sihl yet. Use {{:https://github.com/rgrinberg/opium/tree/master/example/file_upload} this Opium example} meanwhile.

{2:commands Commands}

{3 Introduction}

There are two ways to interact with a Sihl app, via HTTP and via the command line interface (CLI) commands. Sihl has built-in support for both.
In fact, it is often better to implement CLI commands before creating the routes, handlers and views. Commands are a great way to quickly call parts of the app with parameters.

Commands are handled with the module {!Sihl.Command}.

{3 Built-in commands}

Run [make sihl] if you used Spin to create the app, otherwise execute the Sihl app exectuable.

{v
2021-04-10T13:18:34-00:00 [INFO] [sihl.core.app]: Setting up...
2021-04-10T13:18:34-00:00 [INFO] [sihl.core.configuration]: SIHL_ENV: development

Sihl

Run one of the following commands with the argument "help" for more information.

config
gen.html
gen.json
gen.model
gen.view
migrate
random
routes
server
user.admin
v}

This is the list of built-in commands. Whenever you install a package and register Sihl services you get access to more commands.

{3 Custom commands}

Create a file in the directory [app/command] to create custom commands.

{[
let run =

  Sihl.Command.make
    ~name:"todo.add"
    ~usage:"<todo description>"
    ~description:"Adds a new todo to the backlog"
    (fun args ->
      match args with
      | [ description ] ->
        let%lwt _ = Todo.create description in
        Lwt.return (Some ())
      | _ -> Lwt.return None)
;;
]}

Don't forget to pass the list of commands in [run/run.ml] when starting the app:

{[
let () =
  Sihl.App.(
    empty |> with_services services |> run ~commands:[ Command.Add_todo.run ])
;;
]}

Run [make sihl] to see your custom command added to the list of registered commands.

{v
2021-04-10T13:18:34-00:00 [INFO] [sihl.core.app]: Setting up...
2021-04-10T13:18:34-00:00 [INFO] [sihl.core.configuration]: SIHL_ENV: development

Sihl

Run one of the following commands with the argument "help" for more information.

config
gen.html
gen.json
gen.model
gen.view
migrate
random
routes
server
todo.add
user.admin

v}

{2 Generators}

Sihl has built-in generators [gen.model], [gen.view] and [gen.html]. Similar to Rails they help you generating resources, services, repositories and HTML views. Unlike Rails, Sihl doesn't have an abstraction layer for data access (such as an ORM). You should be familiar with SQL.

The generators create files and folders before printing instructions for manual steps to finalize the generation. [gen.html] can create a fully functional CRUD web interface from a schema.

Generators are CLI commands just like [migrate], run the generator commands without any arguments to display help text describing its usage.

{3 Service}

{v
$ make sihl gen.model mariadb order order_number:int premium:bool price:int location:string delivery_date:datetime
2021-04-12T16:20:46-00:00 [INFO] [sihl.core.app]: Setting up...
2021-04-12T16:20:46-00:00 [INFO] [sihl.core.configuration]: SIHL_ENV: development
Wrote file 'sihl-demo/app/domain/order/order.ml'
Wrote file 'sihl-demo/app/domain/order/order.mli'
Wrote file 'sihl-demo/app/domain/order/entity.ml'
Wrote file 'sihl-demo/app/domain/order/repo.ml'
Wrote file 'sihl-demo/app/domain/order/dune'
Wrote file 'sihl-demo/test/order/test.ml'
Wrote file 'sihl-demo/test/order/dune'
Wrote file 'sihl-demo/database/order.ml'
Command 'gen.model' ran successfully in 1.614ms
v}

[gen.model] generates a model consisting of a service, an entity, a reposiory, migrations, and some simple CRUD tests. Note that you have to specify the model name and the database you are using. You can run the tests right after generation.

The created model type contains an [id] of UUID V4 as [string], [created_at] as [Ptime.t] and [updated_at] as [Ptime.t].

{3 View}

{v
$ make sihl gen.view order order_number:int premium:bool price:int location:string delivery_date:datetime
2021-04-12T16:25:48-00:00 [INFO] [sihl.core.app]: Setting up...
2021-04-12T16:25:48-00:00 [INFO] [sihl.core.configuration]: SIHL_ENV: development
Wrote file 'sihl-demo/web/view/order/dune'
Wrote file 'sihl-demo/web/view/order/view_order.ml'
Command 'gen.view' ran successfully in 1.527ms
v}

[gen.view] generates an HTML view for a resource. Note that you don't have to specify a database.

{3 HTML Resource}

{[
$ make sihl gen.html mariadb order order_number:int premium:bool price:int location:string delivery_date:datetime
2021-04-13T07:19:08-00:00 [INFO] [sihl.core.app]: Setting up...
2021-04-13T07:19:08-00:00 [INFO] [sihl.core.configuration]: SIHL_ENV: development
Wrote file 'sihl-demo/app/domain/order/order.ml'
Wrote file 'sihl-demo/app/domain/order/order.mli'
Wrote file 'sihl-demo/app/domain/order/entity.ml'
Wrote file 'sihl-demo/app/domain/order/repo.ml'
Wrote file 'sihl-demo/app/domain/order/dune'
Wrote file 'sihl-demo/test/order/test.ml'
Wrote file 'sihl-demo/test/order/dune'
Wrote file 'sihl-demo/database/order.ml'
Wrote file 'sihl-demo/web/view/order/dune'
Wrote file 'sihl-demo/web/view/order/view_order.ml'

Resource 'orders' created.

Copy this route

    let order =
      Sihl.Web.choose
        ~middlewares:
          [ Sihl.Web.Middleware.csrf ()
          ; Sihl.Web.Middleware.flash ()
          ]
        (Rest.resource
          "orders"
          Order.schema
          (module Order : Rest.SERVICE with type t = Order.t)
          (module View_order : Rest.VIEW with type t = Order.t))
    ;;

into your `routes/routes.ml` and mount it with the HTTP service. Don't forget to add 'order' and 'view_order' to routes/dune.

Add the migration

    Database.Order.all

to the list of migrations before running `sihl migrate`.
You should also run `make format` to apply your styling rules.

Command 'gen.html' ran successfully in 1.964ms
]}

[gen.html] generates a service, a model, a reposiory, simple CRUD tests and an HTML view. Note that you have to specify the service name and the database you are using. You need to do the steps listed manually in order to test the resource.
Once your project compiles, run the tests and browse the root path of the resources to use the fully functional CRUD form.

{%html:
<p align="center">
  <img style="display: block; margin: 0 auto;" src="https://github.com/oxidizing/sihl/blob/master/images/html_rest_index.png?raw=true" alt="HTML Rest Index"/>
</p>
%}

{3 JSON Resource}

This is not yet implemented. Please {{:https://github.com/oxidizing/sihl/issues} open an issue} if you need this feature.

{1:tutorial Tutorial}
Follow the steps in {!getting_started}.

{1:learn_ocaml OCaml for Web Developers}

This section will not tell you all about OCaml but instead give some pointers on where to look things up and list some conventions in Sihl.

{2 Basics}

After studying the {{:https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/basics/intro.html} basics}, you should learn about {{:https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/data/intro.html} data} and {{:https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/hop/intro.html} higher-order programming} in order to manipulate data.

Once you feel comfortable with these concepts, go ahead and read about the remaining Sihl-specific topics.

{2 Error handling}

A good primer can be found {{:https://ocaml.org/learn/tutorials/error_handling.html} here}.

On top of the general error handling patterns in OCaml, there is a convention in Sihl services that you are going to use. Some services return [(unit, string) Result.t Lwt.t] while others return [unit Lwt.t] and raise an exception.

{3 Exception and Option}

Lets look at a function that returns a user given an email address.

{[
(** [find_by_email email] returns a [User.t] if there is a user with an [email]
    address. Raises an [{!Exception}] if no user is found. *)
val find_by_email : string -> t Lwt.t
]}

This function raises an exception if no user was found. But this function can also raise an exception if the connection to the database is broken.
These two cases are different, but both raise exceptions.

If you get the email address from the end user directly, you might want to use this function instead.

{[
(** [find_by_email_opt email] returns a [User.t] if there is a user with email
    address [email]. *)
val find_by_email_opt : string -> t option Lwt.t
]}

If there was no user found, you get [None] back and you can ask your user for the correct email address. This function still raises if the database connection breaks.
The failing database connection is not the user's fault, it can not be recovered by the user doing something else. This is an issue with our infrastructure or our code. The best thing to do here is to let the service raise an exception and let the error middleware handle it with a nice [500] error page.

Use exceptions for errors that are not the fault of a user. The variant [find_by_email] is included for convenient internal usage, when you want to send an email to a list of users in a bulk job for instance.

{3 Result}

Let's take a look at following function:

{[
(** [update_password user ~old new] sets the [new] password of the [user] if the current password matches [old]. *)
val update_password : User.t -> ~old:string -> string -> (unit, string) Result.t Lwt.t
]}

In this case, the function returns an error with an error message if the provided password is wrong. Why can't we just return [unit option Lwt.t] and just act on [None] if something is wrong?

We want to distinguish various invalid user inputs. The user might provide an old password that doesn't match the current one, but the user might also provide a password that is not long enough according to some password policy. In both cases, the user needs to fix the error so we show them the message.

{2 Lwt}

Sihl is built on top of the {{:https://ocsigen.org/tuto/6.4/manual/lwt} Lwt} library, which is similar to Promises in other languages. From the web module to the migration service, everything uses [Lwt] so it is crucial to understand the basic API and usage.

Sihl uses [lwt_ppx] which makes it easy to deal with [Lwt.t] and it gives you better error messages.

{[
let add req =
  match Sihl.Web.Form.find_all req with
  | [ ("description", [ description ]) ] ->
    let%lwt _ = Todo.create description in
    let resp = Opium.Response.redirect_to "/" in
    let resp = Sihl.Web.Flash.set_notice (Some "Successfully updated") resp in
    Lwt.return resp
  | _ ->
    let resp = Opium.Response.redirect_to "/" in
    let resp = Sihl.Web.Flash.set_alert (Some "Failed to update todo description") resp in
    Lwt.return resp
;;
]}

[Todo.create] creates a todo with a description and it returns [unit Lwt.t] on success. In order to keep the code simple, use [let%lwt]. If you use [let%lwt], you have to return ['a Lwt.t], so the last expression has to have an [Lwt].

{2 Build system}

Sihl uses {{:https://dune.build/} dune} as a build system. If you are using the {{:https://github.com/oxidizing/spin-sihl}Spin template}, the most common commands are listed in the [Makefile]. However, since you are in charge of your domain and its directory structure, you should become familiar with the basics of dune.

The {{:https://dune.readthedocs.io/en/stable/quick-start.html} Quickstart} should cover most of it.

{1:api API}

{!modules:
Sihl.Command
Sihl.Env
Sihl.Form
Sihl.Handler
Sihl.Migration
Sihl.Model
Sihl.Query
Sihl.User
}
